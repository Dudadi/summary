https://github.com/libevent/libevent
最近本来在学习libuv，然后同步看了下libevent的库，在这里梳理下
### libevent是什么
libevent是一个通过I/O多路复用事件驱动的高并发C语言库。根据平台选择epoll，poll,kqueue,select等I/O多路复用系统调用。

### libevent如何实现的
1. 高并发和异步
首先讲I/O设置成非阻塞，然后通过I/O多路复用系统调用监听多个FD的读，写，错误，timeout事件。如果触发了文件描述符的读，写，错误，timeout等时间，
再执行相应事件的回调（*当前看的是单线成的，直接在主线程执行读写等回调，会阻塞主线程*）。从直观的看，以HTTP请求为例，服务区会调listen，然后等待客户端连接后调accept。
然后触发read事件，收到请求，并通过send发送给客户端。虽然read和send都是阻塞的I/O（从用户态到内核态，再通过网卡发送或者接受），不过他们的时间占比肯定比数据包在网络中传递要小的多。
因此就算不适用多线程，整体的性能也会高很多。后续通过线程池处理read和send，不阻塞主线程的请求连接，整体的性能会更好。

回调的操作就是进行文件的读写，然后再根据需要往队列里面填加新的事件。比如说服务器的一个HTTP连接，读取完了，需要操作，并通过写事件把信息回复给客户端。

将事件都设置成了非阻塞的，不会阻塞线程，浪费CPU cycle。
同时，通过一个map实现了fd和事件列表的映射，每一次往fd增加事件，都是通过fd获取列表，再往列表插入事件
并通过最小堆实现了最近timeout时间获取。
再设置select等I/O多路复用的超期时间。

2. buffer

### 其他疑问
1. reactor实现，通过子线程处理fd的事件，而非单线程，确保读写不会阻塞主线程的accept连接。如果通过多线程或者多进程实现该事件驱动功能
2. buffer实现
3. 宏的使用和函数以及内联函数的使用场景，该库中使用了很多宏实现了功能。包括泛型，动态使用I/O系统调用等，很巧妙，不过宏也会导致代码阅读性差，是否有必要


### 收获
1. C语言的阅读，C语言虽然简单，不过却非常强大，了解了宏的使用
2. 温习了想队列，堆，hashMap等的C语言实现
3. 非阻塞事件驱动的实现参考

   
